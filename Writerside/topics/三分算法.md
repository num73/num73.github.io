
**原文链接**：[Ternary Search - Algorithms for Competitive Programming (cp-algorithms.com)](https://cp-algorithms.com/num_methods/ternary_search.html)

# 三分算法（Ternary Search）

## 问题

三分算法是解决在$[l, r]$上有定义的单峰函数$f(x)$的区间最值问题的算法。单峰函数是指满足下面任意一个条件的函数：

1. 这个函数开始是严格递增的，达到最大值后（区间的或者整体的最大值）开始严格递减
2. 这个函数开始严格递减，达到最小值后，开始严格递减。

这篇文章中我们只考虑第一种情况，即寻找单峰函数区间上最大值的位置。第二种情况和第一种差不多。

## 算法

考虑区间$[l,r]$上的2个点$m_1$和$m_2$满足$l < m_1 < m_2 < r$。计算函数在点$m_1$和点$m_2$上的值$f(m_1)$和$f(m_2)$。$f(m_2)$和$f(m_2)$的大小关系会出现下面三种情况：

* $f(m_1) < f(m_2)$
  所求的最大值不可能出现在$m_1$的左边，即区间$[l, m_1]$中。因为在这种情况下要么$m_1$和$m_2$都在递增的区间内，要么只有$m_1$在递增区间内。不论哪种成立，最大值都只会出现在区间$[m_1, r]$中。
* $f(m1) > f(m_2)$
  这种情况和前一种类似，最大值不可能出现在$m_2$的右侧，即区间$[m_2, r]$。我们需要搜索的区间减小到了$[l, m_2]$。
* $f(m_1) = f(m_2)$
  我们能够发现这种情况下要么是点$m_1$和点$m_2$都在函数达到最大值的区域内，要么$m_1$处在严格递增的区间内，$m_2$处在严格递减的区间内。因此搜索区间可以减小到$[m_1, m_2]$中。为了在写代码时保持简洁，这种情况可以被包含在上面任意一种情况中。

因此，通过对两个点函数值的比较，我们可以将当前的区间$[l, r]$，换成一个新的，更小的区间$[l', r']$。重复上面的过程，我们可以得到任意小的一个区间。最终这个区间的长度会小于一个特定的值（精确度），然后整个过程就可以停止了。这是一个求解数值问题的方法，所以我们可以假设在$[l, r]$区间内的函数值都是可以接受的最大值。不失一般性，我们可以把$f(l)$当成最终的结果。

$m_1$和$m_2$的选择决定了算法的效率和收敛性。最常见的方式时选择$[l,r]$区间的三分位点。即$m_1$和$m_2$满足：
$$
m_1 = l + \frac{(r - l)}{3}\\
m_2 = r - \frac{r - l}{3}
$$

## 复杂度分析

$$
T(n) = T(2n/3) + O(1) =\Theta(logn)
$$

这个公式的含义是：每一次计算出$m_1$和$m_2$处的函数值后，我们都可以让整个区间减少三分之一。因此要搜索的区间变成了开始的$2/3$​。

应用Master's Theorem，我们可以马上得到所求的复杂度。

## 参数为整数的情况

如果$f(x)$是定义在整数上的函数，区间$[l,r]$就变成离散的了。而我们对$m_1$和$m_2$的选择没有任何的限制，算法的正确性不受影响。$m_1$和$m_2$仍可以选择$[l,r]$区间的三分位点。

和之前不同的是算法的结束条件。三分搜索的循环过程需要在$(r - l) < 3$时结束，因为这种情况我们没办法在$[l,r]$选择不同的两个值，即$m_1$和$m_2$没法再取不同的值，可能会导致死循环。一旦$(r - l) < 3$，通过计算$[l,r]$区间中的所有函数值（不超过两个），可以确定哪个是所求的最大值。

## 算法实现

```c++
double ternary_search(double l, double r) {
    double eps = 1e-9;              //set the error limit here
    while (r - l > eps) {
        double m1 = l + (r - l) / 3;
        double m2 = r - (r - l) / 3;
        double f1 = f(m1);      //evaluates the function at m1
        double f2 = f(m2);      //evaluates the function at m2
        if (f1 < f2)
            l = m1;
        else
            r = m2;
    }
    return f(l);                    //return the maximum of f(x) in [l, r]
}
```

其中`eps`是绝对误差。

除了判断`r - l > eps`外，我们还可以选择一个常数，当循环次数超过这个常数时，算法结束。通常，在多数算法竞赛的题目中，error limit是$10^{-6}$，200-300次循环就足够了。
