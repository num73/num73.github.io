**原文链接：**[Sparse Table - Algorithms for Competitive Programming (cp-algorithms.com)](https://cp-algorithms.com/data_structures/sparse-table.html)


# ST表（Sparse Table）

ST表是一种用于区间查询的数据结构。它上面大部分的区间查询都是$O(logn)$的时间。但它在查询区间最大值最小值问题上非常有效，只需要$O(1)$的时间。

这种数据结构唯一的缺点是只能用于不可变的数组，就是说不支持更新操作。如果数组中元素更新了，那整个数据结构都要重新构造。

## 观察

任何一个非负整数都可以唯一表示为一组递减的2的幂的和，这等价于一个数的二进制表达。例如，$13 = (1101)_2 = 8 + 4 + 1$。对于一个数$x$最多需要$\lceil log_2x \rceil$项。

同样的，任何一个区间都可以被唯一的表示为一组长度为2的幂的不相交区间的并集。比如，$[2,14] = [2,9] \cup [10,13] \cup [14,14]$。其中$[2,14]$区间长度为13，而组成它的三个区间长度分别为8，4，1。同理，区间的数量不超过$\lceil log_2(区间长度) \rceil$。

ST表的关键就是提前计算出所有长度为2的幂的区间的查询。之后任何一个查询都可以被分解成这些已知的查询的和。

## 预处理

我们使用一个二位数组来保存预处理的数据。$st[i][j]$保存长度为$2^i$并且左端点为$j$，即区间为$[j,j+2^i-1]$查询。这个二维数组的大小是$(K+1) \times MAXN$，其中$MAXN$是区间的最大长度。$K$需要满足$K> \lceil log_2 MAXN \rceil$，这是因为$2^{log_2MAXN}$是我们需要预处理保存的最长的区间。对于元素数量小于等于1e7的问题，$K=25$就足够了。

由于计算机缓存的机制的存在，$MAXN$这一维放到数组的第二个维度比较快。

```c
int st[K + 1][MAXN];
```

因为区间$[j,j+2^i - 1]$可以完美地被分解为区间$[j,j+2^{i-1}-1]$和区间$[j+2^{i-1},j+2^i-1]$的并。我们可以通过动态规划的方法来高效地生成预处理的表。

```c
std::copy(array.begin(), array.end(), st[0]);

for (int i = 1; i <= K; i++)
    for (int j = 0; j + (1 << i) <= N; j++)
        st[i][j] = f(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);
```

函数$f$取决于查询的类型，对于求和的查询就是求和函数，对于最小值的查询就是求最小值函数。

预处理的时间复杂度是$O(NlogN)$。

## 区间求和

对于区间求和的查询，函数$f$就是$f(x,y) = x + y$。我们可以用下面的代码构造数据结构：

```c
long long st[K + 1][MAXN];

std::copy(array.begin(), array.end(), st[0]);

for (int i = 1; i <= K; i++)
    for (int j = 0; j + (1 << i) <= N; j++)
        st[i][j] = st[i - 1][j] + st[i - 1][j + (1 << (i - 1))];
```

为了回答区间$[L,R]$的区间查询，我们从大到小迭代2的幂，只要当前$2^i$小于等于区间的长度（$R-L+1$），我们就把区间$[L,L+2^i-1]$的结果加上，继续求区间$[L+2^i,R]$的结果。

```c
long long sum = 0;
for (int i = K; i >= 0; i--) {
    if ((1 << i) <= R - L + 1) {
        sum += st[i][L];
        L += 1 << i;
    }
}
```

区间求和的时间复杂度为$O(K)$，即$O(logMAXN)$。

## 区间最小值查询

区间最值查询就是ST表真正擅长的地方了(It shines in this type of query.)。当查询区间最小值的时候，区间的重叠对结果没有影响。因为相对于把区间分解成多个不相交的区间，我们可以把区间分解成两个长度为2的幂的两个区间，这两个区间可能重叠也可能不重叠。比如，我们可以把区间$[1,6]$分解为区间$[1,4]$和区间$[3,6]$。很显然区间$[1,6]$的最小值，就是区间$[1,4]$和区间$[3,6]$的最小值的最小值。所以我们可以通过下面的式子计算区间$[L,R]$的最小值:
$$
min(st[i][L], st[i][R-2^i + 1]) \quad \text{其中} i=log_2(R-L+1)
$$
这个式子里还需要高效地计算$log_2(R-L+1)$的值，这个可以通过预处理计算出所有需要的log值：

```c
int lg[MAXN+1];
lg[1] = 0;
for (int i = 2; i <= MAXN; i++)
    lg[i] = lg[i/2] + 1;
```

log值也可以在常数时间内动态的计算：

```c
// C++20
#include <bit>
int log2_floor(unsigned long i) {
    return std::bit_width(i) - 1;
}

// pre C++20
int log2_floor(unsigned long long i) {
    return i ? __builtin_clzll(1) - __builtin_clzll(i) : -1;
}
```

压力测试表示使用`lg`数组计算会更慢一些，这是因为计算机缓存机制的存在。

查询区间$[L,R]$结果的代码如下：

```c
int i = lg[R - L + 1];
int minimum = min(st[i][L], st[i][R - (1 << i) + 1]);
```

区间最小值查询的时间复杂度为$O(1)$。